1、方法的签名：方法名＋参数列表
2、方法的重载(overload)
   2.1发生在同一个类中，方法名称相同，参数；列表不同
   2.2编译器在编译时会根据方法的签名自动绑定方法
3、Java规定：构造子类之前必须先构造父类
   在子类构造中若自己不调用父类的构造，默认super()父类的无参构造方法
   若在子类构造中调用了父类的构造，则不在默认提供
   super()调用了父类构造方法，必须位于子类构造方法的第一行
4、向上造型：
   1）父类型的引用指向了子类的对象
   2）能点出来什么，看引用类型
5.重写与重载
  方法的重写：1.发送在父子类中，方法名称相同，参数列表相同，方法体不同
              遵循“运行期绑定”，看对象的类型来调用方法
        重载：1.发生一个类中，方法名称相同，参数列表不同，方法体不同
              遵循“编译器绑定”，看引用的类型来绑定方法
6、修饰符
   public:公开的，任何类
   private:私有的，本类
   protected:受保护的、本类、子类、同包类
   默认的：什么也不写，本类，同包类
   类的访问修饰：public,默认的
7、内存管理:由JVM管理---------------------了解
    1)堆:
      1.1)存储所有new出来的对象(包含成员变量)
  	1.2)没有任何引用所指向的对象为垃圾，
  	    垃圾回收器(GC)不定时到内存中清扫垃圾，
  		回收过程是透明的，但不一定一发现垃圾就立即回收，
  		调用System.gc()建议JVM尽快调度GC来回收垃圾
  	1.3)内存泄漏:不再使用的内存还没有被及时的回收
  	    建议:不再使用的对象及时将引用设置为null
  	1.4)成员变量的生命周期:
  	      创建对象时存在堆中，对象被回收时一并消失
    2)栈:
      2.1)存储正在调用中的方法的所有局部变量(包括参数)
  	2.2)调用方法时，在栈中为该方法分配一块对应的栈帧，
  	    栈帧中存储的是所有的局部变量(包括参数)，
  		方法调用结束时，栈帧被清除，局部变量一并失效
  	2.3)局部变量的生命周期:
  	      调用方法时存在栈中，方法调用结束时与栈帧一并被清除
8、final 最终的、不可改变的----单独应用的几率小
    1)修饰变量:变量不能被改变
    2)修饰方法:方法不能被重写
    3)修饰类:类不能被继承
   2.static final:常量，应用率高
     1)必须声明同时初始化
     2)通过类名点来访问，不能被改变
     3)建议:常量名所有字母都大写，多个单词用_分隔
     4)编译器在编译时直接将常量替换为具体的值，效率高
   3.抽象方法：
     只有方法的定义，没有方法具体的实现
   抽象类：包含抽象方法的类必须是抽象类
 5)抽象类的意义:
    5.1)封装子类共有的属性和行为-------------代码复用
	5.2)为所有子类提供一种统一的类型---------向上造型
	5.3)可以包含抽象方法，为所有子类提供统一的入口
	    每个子类的实现不同，但入口是一致的
5.接口:
  1)是一个标准、规范------------制定方
    遵守了这个标准，就能干某件事------------API后
  2)接口是一种数据类型(引用类型)
  3)由interface定义
  4)只能包含常量和抽象方法
  5)接口不能被实例化
  6)接口是需要被实现的，实现类:
      必须重写接口中的所有抽象方法
  7)一个类可以实现多个接口，用逗号隔开
    若又继承又实现时，应先继承后实现
  8)接口可以继承接口

接口和抽象类的区别：

（1）抽象类可以有构造方法，接口中不能有构造方法。

（2）抽象类中可以有普通成员变量，接口中没有普通成员变量

（3）抽象类中可以包含静态方法，接口中不能包含静态方法

（4） 一个类可以实现多个接口，但只能继承一个抽象类。

（5）接口可以被多重实现，抽象类只能被单一继承

（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法

接口和抽象类的相同点：

(1) 都可以被继承

(2) 都不能被实例化

(3) 都可以包含方法声明

(4) 派生类必须实现未实现的方法

1.多态:
  1)意义:
    1.1)同一类型的引用，指向不同的对象时，有不同的实现
	    -------行为的多态: cut()，run()，teach()...
	1.2)同一个对象，被造型为不同的类型时，有不同的功能
	    -------对象的多态: 我，你，水...
  2)向上造型:
    2.1)父类型的引用指向子类的对象
	2.2)能造型成为的类型有: 父类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口
  4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:在强转之前先使用instanceof来判断引用指向的对象是否是该类型
2.成员内部类:-----实际应用率低
  1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常只能在外部类中创建
  4)内部类中可以直接访问外部类的成员(包括私有的)
    在内部类中有个隐式的引用指向了创建它的外部类对象
	  外部类名.this.
3.匿名内部类:
  1)若想创建一个类(子类)的对象，并且对象只需创建一个
    此时该类不必命名，称之为匿名内部类
  2)内部类中访问外部的变量，该变量必须是final的







